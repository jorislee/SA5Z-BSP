/*
 * SPDX-FileCopyrightText: 2015-2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */
 
#ifndef __XS_ERR_H__
#define __XS_ERR_H__

#include "com.h"
#include "log.h"

#ifdef __cplusplus
extern "C" {
#endif /**< _cplusplus */

typedef int xs_err_t;

/* Definitions for error constants. */

#define XS_ERR_NO_MEM              0x101 /**< Out of memory */
#define XS_ERR_INVALID_ARG         0x102 /**< Invalid argument */
#define XS_ERR_INVALID_STATE       0x103 /**< Invalid state */
#define XS_ERR_INVALID_SIZE        0x104 /**< Invalid size */
#define XS_ERR_NOT_FOUND           0x105 /**< Requested resource not found */
#define XS_ERR_NOT_SUPPORTED       0x106 /**< Operation or feature not supported */
#define XS_ERR_TIMEOUT             0x107 /**< Operation timed out */
#define XS_ERR_INVALID_RESPONSE    0x108 /**< Received response was invalid */
#define XS_ERR_INVALID_CRC         0x109 /**< CRC or checksum was invalid */
#define XS_ERR_INVALID_VERSION     0x10A /**< Version was invalid */
#define XS_ERR_NOT_INIT            0x10B /**< MAC address was invalid */
#define XS_ERR_BUF                 0x10C /**< The buffer is too small */

/**
  * @brief Returns string for xs_err_t error codes
  *
  * This function finds the error code in a pre-generated lookup-table and
  * returns its string representation.
  *
  * The function is generated by the Python script
  * tools/gen_xs_err_to_name.py which should be run each time an xs_err_t
  * error is modified, created or removed from the IDF project.
  *
  * @param code xs_err_t error code
  * @return string error message
  */
const char *xs_err_to_name(xs_err_t code);

/**
 * Macro which can be used to check the error code,
 * and terminate the program in case the code is not XS_OK.
 * Prints the error code, error location, and the failed statement to serial output.
 *
 * Disabled if assertions are disabled.
 */
#define XS_ERROR_CHECK(tag,con, err, format, ...) do { \
        if (con) { \
            if(*format != '\0') \
                XS_LOGE(tag,"<%s> " format, xs_err_to_name(err), ##__VA_ARGS__); \
            return err; \
        } \
    } while(0)

#define XS_WARN_CHECK(tag,con, err, format, ...) do { \
        if (con) { \
            if(*format != '\0') \
                XS_LOGW(tag,"<%s> " format, xs_err_to_name(err), ##__VA_ARGS__); \
            return err; \
        } \
    } while(0)

/**
 * @brief Macro serves similar purpose as ``assert``, except that it checks `esp_err_t`
 *        value rather than a `bool` condition. If the argument of `XS_ERROR_ASSERT`
 *        is not equal `XS_OK`, then an error message is printed on the console,
 *         and `abort()` is called.
 *
 * @note If `IDF monitor` is used, addresses in the backtrace will be converted
 *       to file names and line numbers.
 *
 * @param  err [description]
 * @return     [description]
 */
#define XS_ERROR_ASSERT(tag,err) do { \
        xs_err_t __err_rc = (err); \
        if (__err_rc != XS_OK) { \
            XS_LOGE(tag,"<%s> XS_ERROR_ASSERT failed, at 0x%08x, expression: %s", \
                     xs_err_to_name(__err_rc), (intptr_t)__builtin_return_address(0) - 3, __ASSERT_FUNC); \
            assert(0 && #err); \
        } \
    } while(0)

#define XS_WARN_GOTO(tag,con, lable, format, ...) do { \
        if (con) { \
            if(*format != '\0') \
                XS_LOGW(tag,format, ##__VA_ARGS__); \
            goto lable; \
        } \
    } while(0)

#define XS_ERROR_GOTO(tag,con, lable, format, ...) do { \
        if (con) { \
            if(*format != '\0') \
                XS_LOGE(tag,format, ##__VA_ARGS__); \
            goto lable; \
        } \
    } while(0)

#define XS_WARN_CONTINUE(tag,con, format, ...) { \
        if (con) { \
            if(*format != '\0') \
                XS_LOGW(tag,format, ##__VA_ARGS__); \
            continue; \
        } \
    }

#define XS_ERROR_CONTINUE(tag,con, format, ...) { \
        if (con) { \
            if(*format != '\0') \
                XS_LOGE(tag,format, ##__VA_ARGS__); \
            continue; \
        } \
    }

#define XS_ERROR_BREAK(tag,con, format, ...) { \
        if (con) { \
            if(*format != '\0') \
                XS_LOGE(tag,format, ##__VA_ARGS__); \
            break; \
        } \
    }

#define XS_PARAM_CHECK(tag,con) do { \
        if (!(con)) { \
            XS_LOGE(tag,"<XS_ERR_INVALID_ARG> !(%s)", #con); \
            return XS_ERR_INVALID_ARG; \
        } \
    } while(0)

#define XS_PARAM_GOTO(tag,con, lable) do { \
        if (!(con)) { \
            XS_LOGE(tag,"<XS_ERR_INVALID_ARG> !(%s)", #con); \
            goto lable; \
        } \
    } while(0)

#define XS_PARAM_CONTINUE(tag,con) do { \
        if (!(con)) { \
            XS_LOGE(tag,"<XS_ERR_INVALID_ARG> !(%s)", #con); \
            continue; \
        } \
    } while(0)

#define XS_CHECK_CONTINUE(con) { \
        if (con) { \
            continue; \
        } \
    }

#define XS_CHECK_GOTO(con, lable) do { \
        if (con) { \
            goto lable; \
        } \
    } while(0)
    
#ifdef __cplusplus
}
#endif /**< _cplusplus */
#endif /**< __XS_ERR_H__ */
